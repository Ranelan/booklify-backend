<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/booklify-backend/src/main/java/com/booklify/controller/OrderController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/booklify-backend/src/main/java/com/booklify/controller/OrderController.java" />
              <option name="originalContent" value="package com.booklify.controller;&#10;&#10;import com.booklify.domain.Order;&#10;import com.booklify.service.OrderService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/orders&quot;)&#10;public class OrderController {&#10;&#10;    @Autowired&#10;    private OrderService orderService;&#10;&#10;    @PostMapping(&quot;/create&quot;)&#10;    public ResponseEntity&lt;Order&gt; createOrder(@RequestBody Order order) {&#10;        // Validate the order object&#10;        if (order == null ) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Save the order using the service&#10;        Order savedOrder = orderService.save(order);&#10;&#10;        // Return the saved order with a 201 Created status&#10;        return ResponseEntity.status(201).body(savedOrder);&#10;    }&#10;&#10;    @PutMapping(&quot;/update/{orderId}&quot;)&#10;    public ResponseEntity&lt;Order&gt; updateOrder(@PathVariable Long orderId, @RequestBody Order order) {&#10;        // Validate the order object&#10;        if (order == null || orderId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;        order.setOrderId(orderId); // Ensure the order has the correct ID&#10;        // Update the order using the service&#10;        Order updatedOrder = orderService.update(order);&#10;        // Return the updated order with a 200 OK status&#10;        return ResponseEntity.ok(updatedOrder);&#10;    }&#10;&#10;    @DeleteMapping(&quot;/delete/{orderId}&quot;)&#10;    public ResponseEntity&lt;Void&gt; deleteOrder(@PathVariable Long orderId) {&#10;        // Validate the orderId&#10;        if (orderId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Delete the order using the service&#10;        boolean isDeleted = orderService.deleteById(orderId);&#10;&#10;        if (!isDeleted) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;&#10;        // Return a 204 No Content status&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;&#10;    @GetMapping(&quot;/getById/{orderId}&quot;)&#10;    public ResponseEntity&lt;Order&gt; findByOrderById(@PathVariable Long orderId) {&#10;        // Validate the orderId&#10;        if (orderId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Find the order by ID using the service&#10;        Order order = orderService.findById(orderId);&#10;&#10;        if (order == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;&#10;        // Return the found order with a 200 OK status&#10;        return ResponseEntity.ok(order);&#10;    }&#10;&#10;    @GetMapping(&quot;/getAll&quot;)&#10;    public ResponseEntity&lt;Iterable&lt;Order&gt;&gt; getAll() {&#10;        // Retrieve all orders using the service&#10;        Iterable&lt;Order&gt; orders = orderService.getAll();&#10;&#10;        // Return the list of orders with a 200 OK status&#10;        return ResponseEntity.ok(orders);&#10;    }&#10;&#10;    @GetMapping(&quot;/getByUserId/{userId}&quot;)&#10;    public ResponseEntity&lt;Iterable&lt;Order&gt;&gt; getOrdersByUserId(@PathVariable Long userId) {&#10;        // Validate the userId&#10;        if (userId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Retrieve orders by user ID using the service&#10;        Iterable&lt;Order&gt; orders = orderService.findByRegularUserId(userId);&#10;&#10;        if (orders == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;&#10;        // Return the list of orders with a 200 OK status&#10;        return ResponseEntity.ok(orders);&#10;    }&#10;&#10;    @GetMapping(&quot;/getByOrderDate/{orderDate}&quot;)&#10;    public ResponseEntity&lt;Iterable&lt;Order&gt;&gt; getOrdersByOrderDate(@PathVariable String orderDate) {&#10;        // Parse the orderDate string to LocalDateTime&#10;        LocalDateTime parsedDate;&#10;        try {&#10;            parsedDate = LocalDateTime.parse(orderDate);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;        // Retrieve orders by order date using the service&#10;        Iterable&lt;Order&gt; orders = orderService.findByOrderDate(parsedDate);&#10;        if (orders == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;        // Return the list of orders with a 200 OK status&#10;        return ResponseEntity.ok(orders);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.booklify.controller;&#10;&#10;import com.booklify.domain.Order;&#10;import com.booklify.service.OrderService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/orders&quot;)&#10;public class OrderController {&#10;&#10;    @Autowired&#10;    private OrderService orderService;&#10;&#10;    @PostMapping(&quot;/create&quot;)&#10;    public ResponseEntity&lt;Order&gt; createOrder(@RequestBody Order order) {&#10;        // Validate the order object&#10;        if (order == null ) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Save the order using the service&#10;        Order savedOrder = orderService.save(order);&#10;&#10;        // Return the saved order with a 201 Created status&#10;        return ResponseEntity.status(201).body(savedOrder);&#10;    }&#10;&#10;    @PutMapping(&quot;/update/{orderId}&quot;)&#10;    public ResponseEntity&lt;Order&gt; updateOrder(@PathVariable Long orderId, @RequestBody Order order) {&#10;        // Validate the order object&#10;        if (order == null || orderId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;        // Use builder to set the orderId since setOrderId does not exist&#10;        Order updatedOrder = new Order.OrderBuilder()&#10;            .copy(order)&#10;            .setOrderId(orderId)&#10;            .build();&#10;        updatedOrder = orderService.update(updatedOrder);&#10;        if (updatedOrder == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;        // Return the updated order with a 200 OK status&#10;        return ResponseEntity.ok(updatedOrder);&#10;    }&#10;&#10;    @DeleteMapping(&quot;/delete/{orderId}&quot;)&#10;    public ResponseEntity&lt;Void&gt; deleteOrder(@PathVariable Long orderId) {&#10;        // Validate the orderId&#10;        if (orderId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Delete the order using the service&#10;        boolean isDeleted = orderService.deleteById(orderId);&#10;&#10;        if (!isDeleted) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;&#10;        // Return a 204 No Content status&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;&#10;    @GetMapping(&quot;/getById/{orderId}&quot;)&#10;    public ResponseEntity&lt;Order&gt; findByOrderById(@PathVariable Long orderId) {&#10;        // Validate the orderId&#10;        if (orderId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Find the order by ID using the service&#10;        Order order = orderService.findById(orderId);&#10;&#10;        if (order == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;&#10;        // Return the found order with a 200 OK status&#10;        return ResponseEntity.ok(order);&#10;    }&#10;&#10;    @GetMapping(&quot;/getAll&quot;)&#10;    public ResponseEntity&lt;Iterable&lt;Order&gt;&gt; getAll() {&#10;        // Retrieve all orders using the service&#10;        Iterable&lt;Order&gt; orders = orderService.getAll();&#10;&#10;        // Return the list of orders with a 200 OK status&#10;        return ResponseEntity.ok(orders);&#10;    }&#10;&#10;    @GetMapping(&quot;/getByUserId/{userId}&quot;)&#10;    public ResponseEntity&lt;Iterable&lt;Order&gt;&gt; getOrdersByUserId(@PathVariable Long userId) {&#10;        // Validate the userId&#10;        if (userId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Retrieve orders by user ID using the service&#10;        Iterable&lt;Order&gt; orders = orderService.findByRegularUserId(userId);&#10;&#10;        if (orders == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;&#10;        // Return the list of orders with a 200 OK status&#10;        return ResponseEntity.ok(orders);&#10;    }&#10;&#10;    @GetMapping(&quot;/getByOrderDate/{orderDate}&quot;)&#10;    public ResponseEntity&lt;Iterable&lt;Order&gt;&gt; getOrdersByOrderDate(@PathVariable String orderDate) {&#10;        // Parse the orderDate string to LocalDateTime&#10;        LocalDateTime parsedDate;&#10;        try {&#10;            parsedDate = LocalDateTime.parse(orderDate);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;        // Retrieve orders by order date using the service&#10;        Iterable&lt;Order&gt; orders = orderService.findByOrderDate(parsedDate);&#10;        if (orders == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;        // Return the list of orders with a 200 OK status&#10;        return ResponseEntity.ok(orders);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/booklify-backend/src/test/java/com/booklify/service/OrderServiceTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/booklify-backend/src/test/java/com/booklify/service/OrderServiceTest.java" />
              <option name="originalContent" value="package com.booklify.service;&#10;&#10;import com.booklify.domain.Order;&#10;import com.booklify.domain.RegularUser;&#10;import com.booklify.repository.RegularUserRepository;&#10;import org.junit.jupiter.api.*;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.context.SpringBootTest;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.UUID;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;@SpringBootTest&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;@TestInstance(TestInstance.Lifecycle.PER_CLASS)&#10;class OrderServiceTest {&#10;&#10;    @Autowired&#10;    private OrderService orderService;&#10;&#10;    @Autowired&#10;    private RegularUserRepository regularUserRepository;&#10;&#10;    private Order order;&#10;    private RegularUser regularUser;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Use a random email to avoid unique constraint violation&#10;        String randomEmail = &quot;testUser2_&quot; + UUID.randomUUID() + &quot;@gmail.com&quot;;&#10;        regularUser = new RegularUser.RegularUserBuilder()&#10;                .setFullName(&quot;Test User 2&quot;)&#10;                .setEmail(randomEmail)&#10;                .setPassword(&quot;password2&quot;)&#10;                .setDateJoined(LocalDateTime.now())&#10;                .build();&#10;        regularUser = regularUserRepository.save(regularUser);&#10;        assertNotNull(regularUser.getId(), &quot;Regular User ID should not be null after saving&quot;);&#10;        // Create and save an order for each test&#10;        order = new Order.OrderBuilder()&#10;                .setRegularUser(regularUser)&#10;                .setOrderDate(LocalDateTime.now());&#10;        &#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(1)&#10;    void save() {&#10;        // Create a new order with the initialized regular user&#10;        order = new Order.OrderBuilder()&#10;                .setRegularUser(regularUser)&#10;                .setOrderDate(LocalDateTime.now())&#10;                .build();&#10;&#10;        // Save the order using the service&#10;        Order savedOrder = orderService.save(order);&#10;&#10;        // Validate that the saved order is not null and has an ID&#10;        assertNotNull(savedOrder, &quot;Saved order should not be null&quot;);&#10;        assertNotNull(savedOrder.getOrderId(), &quot;Saved order ID should not be null&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(2)&#10;    void findById() {&#10;        // Ensure the order is saved before finding it&#10;        assertNotNull(order, &quot;Order should not be null before finding by ID&quot;);&#10;&#10;        // Find the order by ID&#10;        Order foundOrder = orderService.findById(order.getOrderId());&#10;&#10;        // Validate that the found order matches the original order&#10;        assertNotNull(foundOrder, &quot;Found order should not be null&quot;);&#10;        assertEquals(order.getOrderId(), foundOrder.getOrderId(), &quot;Found order ID should match the original order ID&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(3)&#10;    void update() {&#10;        // Ensure the order is saved before updating it&#10;        assertNotNull(order, &quot;Order should not be null before updating&quot;);&#10;&#10;        // Update the order's order date&#10;     Order updatedOrder = new Order.OrderBuilder()&#10;                .copy(order)&#10;                .setOrderDate(LocalDateTime.now().plusDays(1)) // Update to a new date&#10;                .build();&#10;&#10;        // Update the order using the service&#10;        Order savedUpdatedOrder = orderService.update(updatedOrder);&#10;&#10;        // Validate that the updated order is not null and has the new order date&#10;        assertNotNull(savedUpdatedOrder, &quot;Updated order should not be null&quot;);&#10;        assertEquals(updatedOrder.getOrderDate(), savedUpdatedOrder.getOrderDate(),&#10;                     &quot;Updated order date should match the new date&quot;);&#10;        assertEquals(order.getOrderId(), savedUpdatedOrder.getOrderId(),&#10;                     &quot;Updated order ID should match the original order ID&quot;);&#10;        assertEquals(order.getRegularUser().getId(), savedUpdatedOrder.getRegularUser().getId(),&#10;                     &quot;Updated order's regular user ID should match the original regular user ID&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(4)&#10;    void getAll() {&#10;        // Retrieve all orders&#10;        var orders = orderService.getAll();&#10;&#10;        // Validate that the list of orders is not null and contains at least one order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(5)&#10;    void findByRegularUserId() {&#10;        // Ensure the regular user is saved before finding orders by user ID&#10;        assertNotNull(regularUser.getId(), &quot;Regular User ID should not be null before finding orders&quot;);&#10;&#10;        // Find orders by regular user ID&#10;        var orders = orderService.findByRegularUserId(regularUser.getId());&#10;&#10;        // Validate that the list of orders is not null and contains the saved order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order for the regular user&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(6)&#10;    void findByOrderDate() {&#10;        // Ensure the order is saved before finding by order date&#10;        assertNotNull(order, &quot;Order should not be null before finding by order date&quot;);&#10;&#10;        // Find orders by order date&#10;        var orders = orderService.findByOrderDate(order.getOrderDate());&#10;&#10;        // Validate that the list of orders is not null and contains the saved order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order for the specified order date&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(7)&#10;    void deleteById() {&#10;        // Ensure the order is saved before deleting it&#10;        assertNotNull(order, &quot;Order should not be null before deletion&quot;);&#10;&#10;        // Delete the order by ID&#10;        boolean isDeleted = orderService.deleteById(order.getOrderId());&#10;&#10;        // Validate that the order was deleted successfully&#10;        assertTrue(isDeleted, &quot;Order should be deleted successfully&quot;);&#10;&#10;        // Attempt to find the deleted order by ID&#10;        assertThrows(RuntimeException.class, () -&gt; orderService.findById(order.getOrderId()),&#10;                     &quot;Finding a deleted order should throw an exception&quot;);&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.booklify.service;&#10;&#10;import com.booklify.domain.Order;&#10;import com.booklify.domain.RegularUser;&#10;import com.booklify.repository.RegularUserRepository;&#10;import org.junit.jupiter.api.*;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.context.SpringBootTest;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.UUID;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;@SpringBootTest&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;@TestInstance(TestInstance.Lifecycle.PER_CLASS)&#10;class OrderServiceTest {&#10;&#10;    @Autowired&#10;    private OrderService orderService;&#10;&#10;    @Autowired&#10;    private RegularUserRepository regularUserRepository;&#10;&#10;    private Order order;&#10;    private RegularUser regularUser;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Use a random email to avoid unique constraint violation&#10;        String randomEmail = &quot;testUser2_&quot; + UUID.randomUUID() + &quot;@gmail.com&quot;;&#10;        regularUser = new RegularUser.RegularUserBuilder()&#10;                .setFullName(&quot;Test User 2&quot;)&#10;                .setEmail(randomEmail)&#10;                .setPassword(&quot;password2&quot;)&#10;                .setDateJoined(LocalDateTime.now())&#10;                .build();&#10;        regularUser = regularUserRepository.save(regularUser);&#10;        assertNotNull(regularUser.getId(), &quot;Regular User ID should not be null after saving&quot;);&#10;        // Create and save an order for each test&#10;        order = new Order.OrderBuilder()&#10;                .setRegularUser(regularUser)&#10;                .setOrderDate(LocalDateTime.now())&#10;                .build();&#10;        &#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(1)&#10;    void save() {&#10;        // Create a new order with the initialized regular user&#10;        order = new Order.OrderBuilder()&#10;                .setRegularUser(regularUser)&#10;                .setOrderDate(LocalDateTime.now())&#10;                .build();&#10;&#10;        // Save the order using the service&#10;        Order savedOrder = orderService.save(order);&#10;&#10;        // Validate that the saved order is not null and has an ID&#10;        assertNotNull(savedOrder, &quot;Saved order should not be null&quot;);&#10;        assertNotNull(savedOrder.getOrderId(), &quot;Saved order ID should not be null&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(2)&#10;    void findById() {&#10;        // Ensure the order is saved before finding it&#10;        assertNotNull(order, &quot;Order should not be null before finding by ID&quot;);&#10;&#10;        // Find the order by ID&#10;        Order foundOrder = orderService.findById(order.getOrderId());&#10;&#10;        // Validate that the found order matches the original order&#10;        assertNotNull(foundOrder, &quot;Found order should not be null&quot;);&#10;        assertEquals(order.getOrderId(), foundOrder.getOrderId(), &quot;Found order ID should match the original order ID&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(3)&#10;    void update() {&#10;        // Ensure the order is saved before updating it&#10;        assertNotNull(order, &quot;Order should not be null before updating&quot;);&#10;&#10;        // Update the order's order date&#10;     Order updatedOrder = new Order.OrderBuilder()&#10;                .copy(order)&#10;                .setOrderDate(LocalDateTime.now().plusDays(1)) // Update to a new date&#10;                .build();&#10;&#10;        // Update the order using the service&#10;        Order savedUpdatedOrder = orderService.update(updatedOrder);&#10;&#10;        // Validate that the updated order is not null and has the new order date&#10;        assertNotNull(savedUpdatedOrder, &quot;Updated order should not be null&quot;);&#10;        assertEquals(updatedOrder.getOrderDate(), savedUpdatedOrder.getOrderDate(),&#10;                     &quot;Updated order date should match the new date&quot;);&#10;        assertEquals(order.getOrderId(), savedUpdatedOrder.getOrderId(),&#10;                     &quot;Updated order ID should match the original order ID&quot;);&#10;        assertEquals(order.getRegularUser().getId(), savedUpdatedOrder.getRegularUser().getId(),&#10;                     &quot;Updated order's regular user ID should match the original regular user ID&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(4)&#10;    void getAll() {&#10;        // Retrieve all orders&#10;        var orders = orderService.getAll();&#10;&#10;        // Validate that the list of orders is not null and contains at least one order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(5)&#10;    void findByRegularUserId() {&#10;        // Ensure the regular user is saved before finding orders by user ID&#10;        assertNotNull(regularUser.getId(), &quot;Regular User ID should not be null before finding orders&quot;);&#10;&#10;        // Find orders by regular user ID&#10;        var orders = orderService.findByRegularUserId(regularUser.getId());&#10;&#10;        // Validate that the list of orders is not null and contains the saved order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order for the regular user&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(6)&#10;    void findByOrderDate() {&#10;        // Ensure the order is saved before finding by order date&#10;        assertNotNull(order, &quot;Order should not be null before finding by order date&quot;);&#10;&#10;        // Find orders by order date&#10;        var orders = orderService.findByOrderDate(order.getOrderDate());&#10;&#10;        // Validate that the list of orders is not null and contains the saved order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order for the specified order date&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(7)&#10;    void deleteById() {&#10;        // Ensure the order is saved before deleting it&#10;        assertNotNull(order, &quot;Order should not be null before deletion&quot;);&#10;&#10;        // Delete the order by ID&#10;        boolean isDeleted = orderService.deleteById(order.getOrderId());&#10;&#10;        // Validate that the order was deleted successfully&#10;        assertTrue(isDeleted, &quot;Order should be deleted successfully&quot;);&#10;&#10;        // Attempt to find the deleted order by ID&#10;        assertThrows(RuntimeException.class, () -&gt; orderService.findById(order.getOrderId()),&#10;                     &quot;Finding a deleted order should throw an exception&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>