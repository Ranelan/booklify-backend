<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/booklify-backend/src/main/java/com/booklify/controller/OrderController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/booklify-backend/src/main/java/com/booklify/controller/OrderController.java" />
<<<<<<< HEAD
              <option name="originalContent" value="package com.booklify.controller;&#10;&#10;import com.booklify.domain.Order;&#10;import com.booklify.service.OrderService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/orders&quot;)&#10;public class OrderController {&#10;&#10;    @Autowired&#10;    private OrderService orderService;&#10;&#10;    @PostMapping(&quot;/create&quot;)&#10;    public ResponseEntity&lt;Order&gt; createOrder(@RequestBody Order order) {&#10;        // Validate the order object&#10;        if (order == null ) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Save the order using the service&#10;        Order savedOrder = orderService.save(order);&#10;&#10;        // Return the saved order with a 201 Created status&#10;        return ResponseEntity.status(201).body(savedOrder);&#10;    }&#10;&#10;    @PutMapping(&quot;/update/{orderId}&quot;)&#10;    public ResponseEntity&lt;Order&gt; updateOrder(@PathVariable Long orderId, @RequestBody Order order) {&#10;        // Validate the order object&#10;        if (order == null || orderId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;        order.setOrderId(orderId); // Ensure the order has the correct ID&#10;        // Update the order using the service&#10;        Order updatedOrder = orderService.update(order);&#10;        // Return the updated order with a 200 OK status&#10;        return ResponseEntity.ok(updatedOrder);&#10;    }&#10;&#10;    @DeleteMapping(&quot;/delete/{orderId}&quot;)&#10;    public ResponseEntity&lt;Void&gt; deleteOrder(@PathVariable Long orderId) {&#10;        // Validate the orderId&#10;        if (orderId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Delete the order using the service&#10;        boolean isDeleted = orderService.deleteById(orderId);&#10;&#10;        if (!isDeleted) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;&#10;        // Return a 204 No Content status&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;&#10;    @GetMapping(&quot;/getById/{orderId}&quot;)&#10;    public ResponseEntity&lt;Order&gt; findByOrderById(@PathVariable Long orderId) {&#10;        // Validate the orderId&#10;        if (orderId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Find the order by ID using the service&#10;        Order order = orderService.findById(orderId);&#10;&#10;        if (order == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;&#10;        // Return the found order with a 200 OK status&#10;        return ResponseEntity.ok(order);&#10;    }&#10;&#10;    @GetMapping(&quot;/getAll&quot;)&#10;    public ResponseEntity&lt;Iterable&lt;Order&gt;&gt; getAll() {&#10;        // Retrieve all orders using the service&#10;        Iterable&lt;Order&gt; orders = orderService.getAll();&#10;&#10;        // Return the list of orders with a 200 OK status&#10;        return ResponseEntity.ok(orders);&#10;    }&#10;&#10;    @GetMapping(&quot;/getByUserId/{userId}&quot;)&#10;    public ResponseEntity&lt;Iterable&lt;Order&gt;&gt; getOrdersByUserId(@PathVariable Long userId) {&#10;        // Validate the userId&#10;        if (userId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Retrieve orders by user ID using the service&#10;        Iterable&lt;Order&gt; orders = orderService.findByRegularUserId(userId);&#10;&#10;        if (orders == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;&#10;        // Return the list of orders with a 200 OK status&#10;        return ResponseEntity.ok(orders);&#10;    }&#10;&#10;    @GetMapping(&quot;/getByOrderDate/{orderDate}&quot;)&#10;    public ResponseEntity&lt;Iterable&lt;Order&gt;&gt; getOrdersByOrderDate(@PathVariable String orderDate) {&#10;        // Parse the orderDate string to LocalDateTime&#10;        LocalDateTime parsedDate;&#10;        try {&#10;            parsedDate = LocalDateTime.parse(orderDate);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;        // Retrieve orders by order date using the service&#10;        Iterable&lt;Order&gt; orders = orderService.findByOrderDate(parsedDate);&#10;        if (orders == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;        // Return the list of orders with a 200 OK status&#10;        return ResponseEntity.ok(orders);&#10;    }&#10;}&#10;" />
=======
              <option name="originalContent" value="package com.booklify.controller;&#10;&#10;import com.booklify.domain.Order;&#10;import com.booklify.service.OrderService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/orders&quot;)&#10;public class OrderController {&#10;&#10;    @Autowired&#10;    private OrderService orderService;&#10;&#10;    @PostMapping(&quot;/create&quot;)&#10;    public ResponseEntity&lt;Order&gt; createOrder(@RequestBody Order order) {&#10;        // Validate the order object&#10;        if (order == null ) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Save the order using the service&#10;        Order savedOrder = orderService.save(order);&#10;&#10;        // Return the saved order with a 201 Created status&#10;        return ResponseEntity.status(201).body(savedOrder);&#10;    }&#10;&#10;    @PutMapping(&quot;/update/{orderId}&quot;)&#10;    public ResponseEntity&lt;Order&gt; updateOrder(@PathVariable Long orderId, @RequestBody Order order) {&#10;        // Validate the order object&#10;        if (order == null || orderId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;        order.setOrderId(orderId); // Ensure the order has the correct ID&#10;        // Update the order using the service&#10;        Order updatedOrder = orderService.update(order);&#10;        if (updatedOrder == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;        // Return the updated order with a 200 OK status&#10;        return ResponseEntity.ok(updatedOrder);&#10;    }&#10;&#10;    @DeleteMapping(&quot;/delete/{orderId}&quot;)&#10;    public ResponseEntity&lt;Void&gt; deleteOrder(@PathVariable Long orderId) {&#10;        // Validate the orderId&#10;        if (orderId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Delete the order using the service&#10;        boolean isDeleted = orderService.deleteById(orderId);&#10;&#10;        if (!isDeleted) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;&#10;        // Return a 204 No Content status&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;&#10;    @GetMapping(&quot;/getById/{orderId}&quot;)&#10;    public ResponseEntity&lt;Order&gt; findByOrderById(@PathVariable Long orderId) {&#10;        // Validate the orderId&#10;        if (orderId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Find the order by ID using the service&#10;        Order order = orderService.findById(orderId);&#10;&#10;        if (order == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;&#10;        // Return the found order with a 200 OK status&#10;        return ResponseEntity.ok(order);&#10;    }&#10;&#10;    @GetMapping(&quot;/getAll&quot;)&#10;    public ResponseEntity&lt;Iterable&lt;Order&gt;&gt; getAll() {&#10;        // Retrieve all orders using the service&#10;        Iterable&lt;Order&gt; orders = orderService.getAll();&#10;&#10;        // Return the list of orders with a 200 OK status&#10;        return ResponseEntity.ok(orders);&#10;    }&#10;&#10;    @GetMapping(&quot;/getByUserId/{userId}&quot;)&#10;    public ResponseEntity&lt;Iterable&lt;Order&gt;&gt; getOrdersByUserId(@PathVariable Long userId) {&#10;        // Validate the userId&#10;        if (userId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Retrieve orders by user ID using the service&#10;        Iterable&lt;Order&gt; orders = orderService.findByRegularUserId(userId);&#10;&#10;        if (orders == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;&#10;        // Return the list of orders with a 200 OK status&#10;        return ResponseEntity.ok(orders);&#10;    }&#10;&#10;    @GetMapping(&quot;/getByOrderDate/{orderDate}&quot;)&#10;    public ResponseEntity&lt;Iterable&lt;Order&gt;&gt; getOrdersByOrderDate(@PathVariable String orderDate) {&#10;        // Parse the orderDate string to LocalDateTime&#10;        LocalDateTime parsedDate;&#10;        try {&#10;            parsedDate = LocalDateTime.parse(orderDate);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;        // Retrieve orders by order date using the service&#10;        Iterable&lt;Order&gt; orders = orderService.findByOrderDate(parsedDate);&#10;        if (orders == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;        // Return the list of orders with a 200 OK status&#10;        return ResponseEntity.ok(orders);&#10;    }&#10;}&#10;" />
>>>>>>> 993b2a6 (Update)
              <option name="updatedContent" value="package com.booklify.controller;&#10;&#10;import com.booklify.domain.Order;&#10;import com.booklify.service.OrderService;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/orders&quot;)&#10;public class OrderController {&#10;&#10;    @Autowired&#10;    private OrderService orderService;&#10;&#10;    @PostMapping(&quot;/create&quot;)&#10;    public ResponseEntity&lt;Order&gt; createOrder(@RequestBody Order order) {&#10;        // Validate the order object&#10;        if (order == null ) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Save the order using the service&#10;        Order savedOrder = orderService.save(order);&#10;&#10;        // Return the saved order with a 201 Created status&#10;        return ResponseEntity.status(201).body(savedOrder);&#10;    }&#10;&#10;    @PutMapping(&quot;/update/{orderId}&quot;)&#10;    public ResponseEntity&lt;Order&gt; updateOrder(@PathVariable Long orderId, @RequestBody Order order) {&#10;        // Validate the order object&#10;        if (order == null || orderId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;        // Use builder to set the orderId since setOrderId does not exist&#10;        Order updatedOrder = new Order.OrderBuilder()&#10;            .copy(order)&#10;            .setOrderId(orderId)&#10;            .build();&#10;        updatedOrder = orderService.update(updatedOrder);&#10;        if (updatedOrder == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;        // Return the updated order with a 200 OK status&#10;        return ResponseEntity.ok(updatedOrder);&#10;    }&#10;&#10;    @DeleteMapping(&quot;/delete/{orderId}&quot;)&#10;    public ResponseEntity&lt;Void&gt; deleteOrder(@PathVariable Long orderId) {&#10;        // Validate the orderId&#10;        if (orderId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Delete the order using the service&#10;        boolean isDeleted = orderService.deleteById(orderId);&#10;&#10;        if (!isDeleted) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;&#10;        // Return a 204 No Content status&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;&#10;    @GetMapping(&quot;/getById/{orderId}&quot;)&#10;    public ResponseEntity&lt;Order&gt; findByOrderById(@PathVariable Long orderId) {&#10;        // Validate the orderId&#10;        if (orderId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Find the order by ID using the service&#10;        Order order = orderService.findById(orderId);&#10;&#10;        if (order == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;&#10;        // Return the found order with a 200 OK status&#10;        return ResponseEntity.ok(order);&#10;    }&#10;&#10;    @GetMapping(&quot;/getAll&quot;)&#10;    public ResponseEntity&lt;Iterable&lt;Order&gt;&gt; getAll() {&#10;        // Retrieve all orders using the service&#10;        Iterable&lt;Order&gt; orders = orderService.getAll();&#10;&#10;        // Return the list of orders with a 200 OK status&#10;        return ResponseEntity.ok(orders);&#10;    }&#10;&#10;    @GetMapping(&quot;/getByUserId/{userId}&quot;)&#10;    public ResponseEntity&lt;Iterable&lt;Order&gt;&gt; getOrdersByUserId(@PathVariable Long userId) {&#10;        // Validate the userId&#10;        if (userId == null) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;&#10;        // Retrieve orders by user ID using the service&#10;        Iterable&lt;Order&gt; orders = orderService.findByRegularUserId(userId);&#10;&#10;        if (orders == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;&#10;        // Return the list of orders with a 200 OK status&#10;        return ResponseEntity.ok(orders);&#10;    }&#10;&#10;    @GetMapping(&quot;/getByOrderDate/{orderDate}&quot;)&#10;    public ResponseEntity&lt;Iterable&lt;Order&gt;&gt; getOrdersByOrderDate(@PathVariable String orderDate) {&#10;        // Parse the orderDate string to LocalDateTime&#10;        LocalDateTime parsedDate;&#10;        try {&#10;            parsedDate = LocalDateTime.parse(orderDate);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.badRequest().build();&#10;        }&#10;        // Retrieve orders by order date using the service&#10;        Iterable&lt;Order&gt; orders = orderService.findByOrderDate(parsedDate);&#10;        if (orders == null) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;        // Return the list of orders with a 200 OK status&#10;        return ResponseEntity.ok(orders);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
<<<<<<< HEAD
=======
        <entry key="$PROJECT_DIR$/booklify-backend/src/main/java/com/booklify/service/OrderService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/booklify-backend/src/main/java/com/booklify/service/OrderService.java" />
              <option name="originalContent" value="package com.booklify.service;&#10;&#10;import com.booklify.domain.Order;&#10;import com.booklify.repository.OrderRepository;&#10;import com.booklify.repository.RegularUserRepository;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;&#10;@Service&#10;public class OrderService implements IOrderService {&#10;&#10;    @Autowired&#10;    private OrderRepository orderRepository;&#10;&#10;    @Autowired&#10;    private RegularUserRepository regularUserRepository;&#10;&#10;&#10;    @Override&#10;    public Order save(Order entity) {&#10;        return orderRepository.save(entity);&#10;    }&#10;&#10;    @Override&#10;    public Order findById(Long aLong) {&#10;        return orderRepository.findById(aLong)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Order not found with id: &quot; + aLong));&#10;    }&#10;&#10;    @Override&#10;    public Order update(Order entity) {&#10;        Order existing = findById(entity.getOrderId());&#10;&#10;        Order updatedOrder = new Order.OrderBuilder()&#10;                .copy(existing)&#10;                .setRegularUser(regularUserRepository.findById(entity.getRegularUser().getId())&#10;                        .orElseThrow(() -&gt; new RuntimeException(&quot;Regular User not found with id: &quot; + entity.getRegularUser().getId())))&#10;                .setOrderDate(entity.getOrderDate())&#10;                .build();&#10;&#10;        return orderRepository.save(updatedOrder);&#10;&#10;    }&#10;&#10;    @Override&#10;    public boolean deleteById(Long aLong) { //Not ideal, but just doing it for now&#10;        Order order = findById(aLong);&#10;        orderRepository.delete(order);&#10;        return false;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Order&gt; getAll() {&#10;        return orderRepository.findAll();&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Order&gt; findByRegularUserId(Long id) {&#10;        return orderRepository.findByRegularUserId(id);&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Order&gt; findByOrderDate(LocalDateTime orderDate) {&#10;        return orderRepository.findByOrderDate(orderDate);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.booklify.service;&#10;&#10;import com.booklify.domain.Order;&#10;import com.booklify.repository.OrderRepository;&#10;import com.booklify.repository.RegularUserRepository;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.List;&#10;&#10;@Service&#10;public class OrderService implements IOrderService {&#10;&#10;    @Autowired&#10;    private OrderRepository orderRepository;&#10;&#10;    @Autowired&#10;    private RegularUserRepository regularUserRepository;&#10;&#10;&#10;    @Override&#10;    public Order save(Order entity) {&#10;        return orderRepository.save(entity);&#10;    }&#10;&#10;    @Override&#10;    public Order findById(Long aLong) {&#10;        return orderRepository.findById(aLong)&#10;                .orElseThrow(() -&gt; new RuntimeException(&quot;Order not found with id: &quot; + aLong));&#10;    }&#10;&#10;    @Override&#10;    public Order update(Order entity) {&#10;        Order existing = findById(entity.getOrderId());&#10;&#10;        Order updatedOrder = new Order.OrderBuilder()&#10;                .copy(existing)&#10;                .setRegularUser(regularUserRepository.findById(entity.getRegularUser().getId())&#10;                        .orElseThrow(() -&gt; new RuntimeException(&quot;Regular User not found with id: &quot; + entity.getRegularUser().getId())))&#10;                .setOrderDate(entity.getOrderDate())&#10;                .build();&#10;&#10;        return orderRepository.save(updatedOrder);&#10;&#10;    }&#10;&#10;    @Override&#10;    public boolean deleteById(Long aLong) {&#10;        Order order = findById(aLong);&#10;        orderRepository.delete(order);&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Order&gt; getAll() {&#10;        return orderRepository.findAll();&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Order&gt; findByRegularUserId(Long id) {&#10;        return orderRepository.findByRegularUserId(id);&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Order&gt; findByOrderDate(LocalDateTime orderDate) {&#10;        return orderRepository.findByOrderDate(orderDate);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/booklify-backend/src/main/java/com/booklify/util/Helper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/booklify-backend/src/main/java/com/booklify/util/Helper.java" />
              <option name="originalContent" value="package com.booklify.util;&#10;&#10;import java.util.regex.Pattern;&#10;&#10;public class Helper {&#10;&#10;    public static boolean isNullOrEmpty(String str) {&#10;        return str == null || str.isEmpty();&#10;    }&#10;&#10;    public static boolean isValidDateTime(java.time.LocalDateTime createdAt) {&#10;        return createdAt != null &amp;&amp; !createdAt.isAfter(java.time.LocalDateTime.now());&#10;    }&#10;&#10;    public static boolean isValidSellerRating(double rating) {&#10;        return rating &gt;= 0.0 &amp;&amp; rating &lt;= 5.0;&#10;    }&#10;&#10;    public static boolean isValidEmail(String email) {&#10;        if (isNullOrEmpty(email)) return false;&#10;        String emailRegex = &quot;^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$&quot;;&#10;        return Pattern.matches(emailRegex, email);&#10;    }&#10;&#10;    public static boolean isValidPassword(String password) {&#10;        if (isNullOrEmpty(password)) return false;&#10;        String passwordRegex = &quot;^(?=.*[A-Za-z])(?=.*\\d).{6,}$&quot;;&#10;        return Pattern.matches(passwordRegex, password);&#10;    }&#10;&#10;    public static boolean isValidPhoneNumber(String phoneNumber) {&#10;        if (isNullOrEmpty(phoneNumber)) return false;&#10;        String phoneRegex = &quot;^\\+?[0-9]{10,15}$&quot;; // Example regex for international phone numbers&#10;        return Pattern.matches(phoneRegex, phoneNumber);&#10;    }&#10;&#10;    public static boolean isValidISBN(String isbn) {&#10;        if (isNullOrEmpty(isbn)) return false;&#10;        String isbnRegex = &quot;^(97(8|9))?\\d{9}(\\d|X)$&quot;; // Regex for ISBN-10 and ISBN-13&#10;        return Pattern.matches(isbnRegex, isbn);&#10;    }&#10;&#10;    //for the book images&#10;&#10;    public static boolean isValidImageType(byte[] image) {&#10;        // Simple check for common image formats&#10;        if (image.length &lt; 4) return false;&#10;&#10;        // PNG check&#10;        if (image[0] == (byte) 0x89 &amp;&amp; image[1] == 'P' &amp;&amp; image[2] == 'N' &amp;&amp; image[3] == 'G') {&#10;            return true;&#10;        }&#10;        // JPEG check&#10;        if (image[0] == (byte) 0xFF &amp;&amp; image[1] == (byte) 0xD8) {&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public static boolean isValidQuantity(int quantity) {&#10;        return quantity &gt; 0; // Quantity must be a positive integer&#10;    }&#10;&#10;    public static boolean isValidPrice(Double price) {&#10;        return price != null &amp;&amp; price &gt;= 0; // Price must be a non-negative number&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.booklify.util;&#10;&#10;import java.util.regex.Pattern;&#10;&#10;public class Helper {&#10;&#10;    public static boolean isNullOrEmpty(String str) {&#10;        return str == null || str.isEmpty();&#10;    }&#10;&#10;    public static boolean isValidDateTime(java.time.LocalDateTime createdAt) {&#10;        return createdAt != null &amp;&amp; !createdAt.isAfter(java.time.LocalDateTime.now());&#10;    }&#10;&#10;    public static boolean isValidSellerRating(double rating) {&#10;        return rating &gt;= 0.0 &amp;&amp; rating &lt;= 5.0;&#10;    }&#10;&#10;    public static boolean isValidEmail(String email) {&#10;        if (isNullOrEmpty(email)) return false;&#10;        String emailRegex = &quot;^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$&quot;;&#10;        return Pattern.matches(emailRegex, email);&#10;    }&#10;&#10;    public static boolean isValidPassword(String password) {&#10;        if (isNullOrEmpty(password)) return false;&#10;        String passwordRegex = &quot;^(?=.*[A-Za-z])(?=.*\\d).{6,}$&quot;;&#10;        return Pattern.matches(passwordRegex, password);&#10;    }&#10;&#10;    public static boolean isValidPhoneNumber(String phoneNumber) {&#10;        if (isNullOrEmpty(phoneNumber)) return false;&#10;        String phoneRegex = &quot;^\\+?[0-9]{10,15}$&quot;; // Example regex for international phone numbers&#10;        return Pattern.matches(phoneRegex, phoneNumber);&#10;    }&#10;&#10;    public static boolean isValidISBN(String isbn) {&#10;        if (isNullOrEmpty(isbn)) return false;&#10;        String isbnRegex = &quot;^(97(8|9))?\\d{9}(\\d|X)$&quot;; // Regex for ISBN-10 and ISBN-13&#10;        return Pattern.matches(isbnRegex, isbn);&#10;    }&#10;&#10;    //for the book images&#10;&#10;    public static boolean isValidImageType(byte[] image) {&#10;        // Simple check for common image formats&#10;        if (image.length &lt; 4) return false;&#10;&#10;        // PNG check&#10;        if (image[0] == (byte) 0x89 &amp;&amp; image[1] == 'P' &amp;&amp; image[2] == 'N' &amp;&amp; image[3] == 'G') {&#10;            return true;&#10;        }&#10;        // JPEG check&#10;        if (image[0] == (byte) 0xFF &amp;&amp; image[1] == (byte) 0xD8) {&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public static boolean isValidQuantity(int quantity) {&#10;        return quantity &gt; 0; // Quantity must be a positive integer&#10;    }&#10;&#10;    public static boolean isValidPrice(double price) {&#10;        return price &gt; 0.0; // Price must be a non-negative number&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/booklify-backend/src/test/java/com/booklify/controller/OrderControllerTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/booklify-backend/src/test/java/com/booklify/controller/OrderControllerTest.java" />
              <option name="originalContent" value="package com.booklify.controller;&#10;&#10;import com.booklify.domain.Order;&#10;import com.booklify.domain.RegularUser;&#10;import com.booklify.factory.OrderFactory;&#10;import com.booklify.factory.RegularUserFactory;&#10;import com.booklify.repository.RegularUserRepository;&#10;import org.junit.jupiter.api.*;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.context.SpringBootTest;&#10;import org.springframework.boot.test.web.client.TestRestTemplate;&#10;import org.springframework.boot.test.web.server.LocalServerPort;&#10;import org.springframework.http.ResponseEntity;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.UUID;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;@TestInstance(TestInstance.Lifecycle.PER_CLASS)&#10;class OrderControllerTest {&#10;&#10;    private Order order;&#10;    private RegularUser regularUser;&#10;&#10;    @LocalServerPort&#10;    private int port;&#10;&#10;    @Autowired&#10;    private TestRestTemplate testRestTemplate;&#10;&#10;    @Autowired&#10;    private RegularUserRepository regularUserRepository;&#10;&#10;    private String createdOrderDateStr;&#10;&#10;    private String getBaseUrl() {&#10;        return &quot;http://localhost:&quot; + port + &quot;/api/orders&quot;;&#10;    }&#10;&#10;    @BeforeAll&#10;    void setUp() {&#10;&#10;        // Use a random email to avoid unique constraint violation&#10;        String randomEmail = &quot;testUser_&quot; + UUID.randomUUID() + &quot;@gmail.com&quot;;&#10;        regularUser = RegularUserFactory.createRegularUser(&quot;Test User&quot;, randomEmail, &quot;password123&quot;, LocalDateTime.now(), 4.5, &quot;Test bio&quot;, LocalDateTime.now());&#10;        regularUser = regularUserRepository.save(regularUser);&#10;&#10;        order = (Order) OrderFactory.createOrder(LocalDateTime.now(), regularUser);&#10;        String url = getBaseUrl() + &quot;/create&quot;;&#10;        ResponseEntity&lt;Order&gt; response = testRestTemplate.postForEntity(url, order, Order.class);&#10;        assertEquals(201, response.getStatusCode().value(), &quot;Response status should be 201&quot;);&#10;        assertNotNull(response.getBody(), &quot;Response body should not be null&quot;);&#10;        order = response.getBody(); // Use the created order with generated ID for all tests&#10;        createdOrderDateStr = order.getOrderDate().withNano(0).toString(); // Store the original order date for date-based queries&#10;    }&#10;&#10;    @org.junit.jupiter.api.Test&#10;    @org.junit.jupiter.api.Order(1)&#10;    void createOrder() {&#10;        assertNotNull(order);&#10;        assertNotNull(order.getOrderId(), &quot;Order ID should not be null after creation&quot;);&#10;    }&#10;&#10;    @org.junit.jupiter.api.Test&#10;    @org.junit.jupiter.api.Order(2)&#10;    void updateOrder() {&#10;        String url = getBaseUrl() + &quot;/update/&quot; + order.getOrderId();&#10;        // Use builder to update orderDate&#10;        Order updatedOrder = new Order.OrderBuilder()&#10;                .copy(order)&#10;                .setOrderDate(order.getOrderDate().plusDays(1))&#10;                .build();&#10;        ResponseEntity&lt;Order&gt; response = testRestTemplate.exchange(url, org.springframework.http.HttpMethod.PUT, new org.springframework.http.HttpEntity&lt;&gt;(updatedOrder), Order.class);&#10;        assertEquals(200, response.getStatusCode().value(), &quot;Response status should be 200&quot;);&#10;        assertNotNull(response.getBody(), &quot;Response body should not be null&quot;);&#10;        assertEquals(order.getOrderId(), response.getBody().getOrderId(), &quot;Order ID should match after update&quot;);&#10;        assertEquals(updatedOrder.getOrderDate(), response.getBody().getOrderDate(), &quot;Order date should be updated&quot;);&#10;        // Update the stored order and date string for subsequent tests&#10;        order = response.getBody();&#10;        createdOrderDateStr = order.getOrderDate().withNano(0).toString();&#10;    }&#10;&#10;    @org.junit.jupiter.api.Test&#10;    @org.junit.jupiter.api.Order(3)&#10;    void findByOrderById() {&#10;        String url = getBaseUrl() + &quot;/getById/&quot; + order.getOrderId();&#10;        ResponseEntity&lt;Order&gt; response = testRestTemplate.getForEntity(url, Order.class);&#10;        assertEquals(200, response.getStatusCode().value(), &quot;Response status should be 200&quot;);&#10;        assertNotNull(response.getBody(), &quot;Order should be found by ID&quot;);&#10;        assertEquals(order.getOrderId(), response.getBody().getOrderId(), &quot;Order ID should match&quot;);&#10;    }&#10;&#10;    @org.junit.jupiter.api.Test&#10;    @org.junit.jupiter.api.Order(4)&#10;    void getAll() {&#10;        String url = getBaseUrl() + &quot;/getAll&quot;;&#10;        ResponseEntity&lt;Order[]&gt; response = testRestTemplate.getForEntity(url, Order[].class);&#10;        assertEquals(200, response.getStatusCode().value(), &quot;Response status should be 200&quot;);&#10;        assertNotNull(response.getBody(), &quot;Response body should not be null&quot;);&#10;        assertTrue(response.getBody().length &gt; 0, &quot;There should be at least one order&quot;);&#10;    }&#10;&#10;    @org.junit.jupiter.api.Test&#10;    @org.junit.jupiter.api.Order(5)&#10;    void getOrdersByUserId() {&#10;        String url = getBaseUrl() + &quot;/getByUserId/&quot; + regularUser.getId();&#10;        ResponseEntity&lt;Order[]&gt; response = testRestTemplate.getForEntity(url, Order[].class);&#10;        assertEquals(200, response.getStatusCode().value(), &quot;Response status should be 200&quot;);&#10;        assertNotNull(response.getBody(), &quot;Response body should not be null&quot;);&#10;        assertTrue(response.getBody().length &gt; 0, &quot;User should have at least one order&quot;);&#10;    }&#10;&#10;    @org.junit.jupiter.api.Test&#10;    @org.junit.jupiter.api.Order(6)&#10;    void getOrdersByOrderDate() {&#10;        String url = getBaseUrl() + &quot;/getByOrderDate/&quot; + createdOrderDateStr;&#10;        ResponseEntity&lt;Order[]&gt; response = testRestTemplate.getForEntity(url, Order[].class);&#10;        assertEquals(200, response.getStatusCode().value(), &quot;Response status should be 200&quot;);&#10;        assertNotNull(response.getBody(), &quot;Response body should not be null&quot;);&#10;        assertTrue(response.getBody().length &gt; 0, &quot;There should be at least one order for the given date&quot;);&#10;    }&#10;&#10;&#10;//    @org.junit.jupiter.api.Test&#10;//    @org.junit.jupiter.api.Order(7)&#10;//    void deleteOrder() {&#10;//        String url = getBaseUrl() + &quot;/delete/&quot; + order.getOrderId();&#10;//        ResponseEntity&lt;Void&gt; deleteResponse = testRestTemplate.exchange(url, org.springframework.http.HttpMethod.DELETE, null, Void.class);&#10;//        assertEquals(204, deleteResponse.getStatusCode().value(), &quot;Delete should return 204 No Content&quot;);&#10;//        // Try to fetch the deleted order&#10;//        ResponseEntity&lt;Order&gt; response = testRestTemplate.getForEntity(getBaseUrl() + &quot;/getById/&quot; + order.getOrderId(), Order.class);&#10;//        assertEquals(404, response.getStatusCode().value(), &quot;Order should not be found after deletion&quot;);&#10;//    }&#10;&#10;}" />
              <option name="updatedContent" value="package com.booklify.controller;&#10;&#10;import com.booklify.domain.Order;&#10;import com.booklify.domain.RegularUser;&#10;import com.booklify.factory.OrderFactory;&#10;import com.booklify.factory.RegularUserFactory;&#10;import com.booklify.repository.RegularUserRepository;&#10;import org.junit.jupiter.api.*;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.context.SpringBootTest;&#10;import org.springframework.boot.test.web.client.TestRestTemplate;&#10;import org.springframework.boot.test.web.server.LocalServerPort;&#10;import org.springframework.http.ResponseEntity;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.UUID;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;@TestInstance(TestInstance.Lifecycle.PER_CLASS)&#10;class OrderControllerTest {&#10;&#10;    private Order order;&#10;    private RegularUser regularUser;&#10;&#10;    @LocalServerPort&#10;    private int port;&#10;&#10;    @Autowired&#10;    private TestRestTemplate testRestTemplate;&#10;&#10;    @Autowired&#10;    private RegularUserRepository regularUserRepository;&#10;&#10;    private String createdOrderDateStr;&#10;&#10;    private String getBaseUrl() {&#10;        return &quot;http://localhost:&quot; + port + &quot;/api/orders&quot;;&#10;    }&#10;&#10;    @BeforeAll&#10;    void setUp() {&#10;&#10;        // Use a random email to avoid unique constraint violation&#10;        String randomEmail = &quot;testUser_&quot; + UUID.randomUUID() + &quot;@gmail.com&quot;;&#10;        regularUser = RegularUserFactory.createRegularUser(&quot;Test User&quot;, randomEmail, &quot;password123&quot;, LocalDateTime.now(), 4.5, &quot;Test bio&quot;, LocalDateTime.now());&#10;        regularUser = regularUserRepository.save(regularUser);&#10;&#10;        order = (Order) OrderFactory.createOrder(LocalDateTime.now(), regularUser);&#10;        String url = getBaseUrl() + &quot;/create&quot;;&#10;        ResponseEntity&lt;Order&gt; response = testRestTemplate.postForEntity(url, order, Order.class);&#10;        assertEquals(201, response.getStatusCode().value(), &quot;Response status should be 201&quot;);&#10;        assertNotNull(response.getBody(), &quot;Response body should not be null&quot;);&#10;        order = response.getBody(); // Use the created order with generated ID for all tests&#10;        createdOrderDateStr = order.getOrderDate().withNano(0).toString(); // Store the original order date for date-based queries&#10;    }&#10;&#10;    @org.junit.jupiter.api.Test&#10;    @org.junit.jupiter.api.Order(1)&#10;    void createOrder() {&#10;        assertNotNull(order);&#10;        assertNotNull(order.getOrderId(), &quot;Order ID should not be null after creation&quot;);&#10;    }&#10;&#10;    @org.junit.jupiter.api.Test&#10;    @org.junit.jupiter.api.Order(2)&#10;    void updateOrder() {&#10;        String url = getBaseUrl() + &quot;/update/&quot; + order.getOrderId();&#10;        // Use builder to update orderDate&#10;        Order updatedOrder = new Order.OrderBuilder()&#10;                .copy(order)&#10;                .setOrderDate(order.getOrderDate().plusDays(1))&#10;                .build();&#10;        ResponseEntity&lt;Order&gt; response = testRestTemplate.exchange(url, org.springframework.http.HttpMethod.PUT, new org.springframework.http.HttpEntity&lt;&gt;(updatedOrder), Order.class);&#10;        assertEquals(200, response.getStatusCode().value(), &quot;Response status should be 200&quot;);&#10;        assertNotNull(response.getBody(), &quot;Response body should not be null&quot;);&#10;        assertEquals(order.getOrderId(), response.getBody().getOrderId(), &quot;Order ID should match after update&quot;);&#10;        assertEquals(updatedOrder.getOrderDate(), response.getBody().getOrderDate(), &quot;Order date should be updated&quot;);&#10;        // Update the stored order and date string for subsequent tests&#10;        order = response.getBody();&#10;        createdOrderDateStr = order.getOrderDate().withNano(0).toString();&#10;    }&#10;&#10;    @org.junit.jupiter.api.Test&#10;    @org.junit.jupiter.api.Order(3)&#10;    void findByOrderById() {&#10;        String url = getBaseUrl() + &quot;/getById/&quot; + order.getOrderId();&#10;        ResponseEntity&lt;Order&gt; response = testRestTemplate.getForEntity(url, Order.class);&#10;        assertEquals(200, response.getStatusCode().value(), &quot;Response status should be 200&quot;);&#10;        assertNotNull(response.getBody(), &quot;Order should be found by ID&quot;);&#10;        assertEquals(order.getOrderId(), response.getBody().getOrderId(), &quot;Order ID should match&quot;);&#10;    }&#10;&#10;    @org.junit.jupiter.api.Test&#10;    @org.junit.jupiter.api.Order(4)&#10;    void getAll() {&#10;        String url = getBaseUrl() + &quot;/getAll&quot;;&#10;        ResponseEntity&lt;Order[]&gt; response = testRestTemplate.getForEntity(url, Order[].class);&#10;        assertEquals(200, response.getStatusCode().value(), &quot;Response status should be 200&quot;);&#10;        assertNotNull(response.getBody(), &quot;Response body should not be null&quot;);&#10;        assertTrue(response.getBody().length &gt; 0, &quot;There should be at least one order&quot;);&#10;    }&#10;&#10;    @org.junit.jupiter.api.Test&#10;    @org.junit.jupiter.api.Order(5)&#10;    void getOrdersByUserId() {&#10;        String url = getBaseUrl() + &quot;/getByUserId/&quot; + regularUser.getId();&#10;        ResponseEntity&lt;Order[]&gt; response = testRestTemplate.getForEntity(url, Order[].class);&#10;        assertEquals(200, response.getStatusCode().value(), &quot;Response status should be 200&quot;);&#10;        assertNotNull(response.getBody(), &quot;Response body should not be null&quot;);&#10;        assertTrue(response.getBody().length &gt; 0, &quot;User should have at least one order&quot;);&#10;    }&#10;&#10;    @org.junit.jupiter.api.Test&#10;    @org.junit.jupiter.api.Order(6)&#10;    void getOrdersByOrderDate() {&#10;        String url = getBaseUrl() + &quot;/getByOrderDate/&quot; + createdOrderDateStr;&#10;        System.out.println(&quot;Querying for orderDate: &quot; + createdOrderDateStr);&#10;        ResponseEntity&lt;Order[]&gt; response = testRestTemplate.getForEntity(url, Order[].class);&#10;        assertEquals(200, response.getStatusCode().value(), &quot;Response status should be 200&quot;);&#10;        assertNotNull(response.getBody(), &quot;Response body should not be null&quot;);&#10;        System.out.println(&quot;Orders returned: &quot; + response.getBody().length);&#10;        for (Order o : response.getBody()) {&#10;            System.out.println(&quot;OrderId: &quot; + o.getOrderId() + &quot;, orderDate: &quot; + o.getOrderDate());&#10;        }&#10;        assertTrue(response.getBody().length &gt; 0, &quot;There should be at least one order for the given date&quot;);&#10;    }&#10;&#10;&#10;//    @org.junit.jupiter.api.Test&#10;//    @org.junit.jupiter.api.Order(7)&#10;//    void deleteOrder() {&#10;//        String url = getBaseUrl() + &quot;/delete/&quot; + order.getOrderId();&#10;//        ResponseEntity&lt;Void&gt; deleteResponse = testRestTemplate.exchange(url, org.springframework.http.HttpMethod.DELETE, null, Void.class);&#10;//        assertEquals(204, deleteResponse.getStatusCode().value(), &quot;Delete should return 204 No Content&quot;);&#10;//        // Try to fetch the deleted order&#10;//        ResponseEntity&lt;Order&gt; response = testRestTemplate.getForEntity(getBaseUrl() + &quot;/getById/&quot; + order.getOrderId(), Order.class);&#10;//        assertEquals(404, response.getStatusCode().value(), &quot;Order should not be found after deletion&quot;);&#10;//    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
>>>>>>> 993b2a6 (Update)
        <entry key="$PROJECT_DIR$/booklify-backend/src/test/java/com/booklify/service/OrderServiceTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/booklify-backend/src/test/java/com/booklify/service/OrderServiceTest.java" />
<<<<<<< HEAD
              <option name="originalContent" value="package com.booklify.service;&#10;&#10;import com.booklify.domain.Order;&#10;import com.booklify.domain.RegularUser;&#10;import com.booklify.repository.RegularUserRepository;&#10;import org.junit.jupiter.api.*;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.context.SpringBootTest;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.UUID;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;@SpringBootTest&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;@TestInstance(TestInstance.Lifecycle.PER_CLASS)&#10;class OrderServiceTest {&#10;&#10;    @Autowired&#10;    private OrderService orderService;&#10;&#10;    @Autowired&#10;    private RegularUserRepository regularUserRepository;&#10;&#10;    private Order order;&#10;    private RegularUser regularUser;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Use a random email to avoid unique constraint violation&#10;        String randomEmail = &quot;testUser2_&quot; + UUID.randomUUID() + &quot;@gmail.com&quot;;&#10;        regularUser = new RegularUser.RegularUserBuilder()&#10;                .setFullName(&quot;Test User 2&quot;)&#10;                .setEmail(randomEmail)&#10;                .setPassword(&quot;password2&quot;)&#10;                .setDateJoined(LocalDateTime.now())&#10;                .build();&#10;        regularUser = regularUserRepository.save(regularUser);&#10;        assertNotNull(regularUser.getId(), &quot;Regular User ID should not be null after saving&quot;);&#10;        // Create and save an order for each test&#10;        order = new Order.OrderBuilder()&#10;                .setRegularUser(regularUser)&#10;                .setOrderDate(LocalDateTime.now());&#10;        &#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(1)&#10;    void save() {&#10;        // Create a new order with the initialized regular user&#10;        order = new Order.OrderBuilder()&#10;                .setRegularUser(regularUser)&#10;                .setOrderDate(LocalDateTime.now())&#10;                .build();&#10;&#10;        // Save the order using the service&#10;        Order savedOrder = orderService.save(order);&#10;&#10;        // Validate that the saved order is not null and has an ID&#10;        assertNotNull(savedOrder, &quot;Saved order should not be null&quot;);&#10;        assertNotNull(savedOrder.getOrderId(), &quot;Saved order ID should not be null&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(2)&#10;    void findById() {&#10;        // Ensure the order is saved before finding it&#10;        assertNotNull(order, &quot;Order should not be null before finding by ID&quot;);&#10;&#10;        // Find the order by ID&#10;        Order foundOrder = orderService.findById(order.getOrderId());&#10;&#10;        // Validate that the found order matches the original order&#10;        assertNotNull(foundOrder, &quot;Found order should not be null&quot;);&#10;        assertEquals(order.getOrderId(), foundOrder.getOrderId(), &quot;Found order ID should match the original order ID&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(3)&#10;    void update() {&#10;        // Ensure the order is saved before updating it&#10;        assertNotNull(order, &quot;Order should not be null before updating&quot;);&#10;&#10;        // Update the order's order date&#10;     Order updatedOrder = new Order.OrderBuilder()&#10;                .copy(order)&#10;                .setOrderDate(LocalDateTime.now().plusDays(1)) // Update to a new date&#10;                .build();&#10;&#10;        // Update the order using the service&#10;        Order savedUpdatedOrder = orderService.update(updatedOrder);&#10;&#10;        // Validate that the updated order is not null and has the new order date&#10;        assertNotNull(savedUpdatedOrder, &quot;Updated order should not be null&quot;);&#10;        assertEquals(updatedOrder.getOrderDate(), savedUpdatedOrder.getOrderDate(),&#10;                     &quot;Updated order date should match the new date&quot;);&#10;        assertEquals(order.getOrderId(), savedUpdatedOrder.getOrderId(),&#10;                     &quot;Updated order ID should match the original order ID&quot;);&#10;        assertEquals(order.getRegularUser().getId(), savedUpdatedOrder.getRegularUser().getId(),&#10;                     &quot;Updated order's regular user ID should match the original regular user ID&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(4)&#10;    void getAll() {&#10;        // Retrieve all orders&#10;        var orders = orderService.getAll();&#10;&#10;        // Validate that the list of orders is not null and contains at least one order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(5)&#10;    void findByRegularUserId() {&#10;        // Ensure the regular user is saved before finding orders by user ID&#10;        assertNotNull(regularUser.getId(), &quot;Regular User ID should not be null before finding orders&quot;);&#10;&#10;        // Find orders by regular user ID&#10;        var orders = orderService.findByRegularUserId(regularUser.getId());&#10;&#10;        // Validate that the list of orders is not null and contains the saved order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order for the regular user&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(6)&#10;    void findByOrderDate() {&#10;        // Ensure the order is saved before finding by order date&#10;        assertNotNull(order, &quot;Order should not be null before finding by order date&quot;);&#10;&#10;        // Find orders by order date&#10;        var orders = orderService.findByOrderDate(order.getOrderDate());&#10;&#10;        // Validate that the list of orders is not null and contains the saved order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order for the specified order date&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(7)&#10;    void deleteById() {&#10;        // Ensure the order is saved before deleting it&#10;        assertNotNull(order, &quot;Order should not be null before deletion&quot;);&#10;&#10;        // Delete the order by ID&#10;        boolean isDeleted = orderService.deleteById(order.getOrderId());&#10;&#10;        // Validate that the order was deleted successfully&#10;        assertTrue(isDeleted, &quot;Order should be deleted successfully&quot;);&#10;&#10;        // Attempt to find the deleted order by ID&#10;        assertThrows(RuntimeException.class, () -&gt; orderService.findById(order.getOrderId()),&#10;                     &quot;Finding a deleted order should throw an exception&quot;);&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.booklify.service;&#10;&#10;import com.booklify.domain.Order;&#10;import com.booklify.domain.RegularUser;&#10;import com.booklify.repository.RegularUserRepository;&#10;import org.junit.jupiter.api.*;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.context.SpringBootTest;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.UUID;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;@SpringBootTest&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;@TestInstance(TestInstance.Lifecycle.PER_CLASS)&#10;class OrderServiceTest {&#10;&#10;    @Autowired&#10;    private OrderService orderService;&#10;&#10;    @Autowired&#10;    private RegularUserRepository regularUserRepository;&#10;&#10;    private Order order;&#10;    private RegularUser regularUser;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Use a random email to avoid unique constraint violation&#10;        String randomEmail = &quot;testUser2_&quot; + UUID.randomUUID() + &quot;@gmail.com&quot;;&#10;        regularUser = new RegularUser.RegularUserBuilder()&#10;                .setFullName(&quot;Test User 2&quot;)&#10;                .setEmail(randomEmail)&#10;                .setPassword(&quot;password2&quot;)&#10;                .setDateJoined(LocalDateTime.now())&#10;                .build();&#10;        regularUser = regularUserRepository.save(regularUser);&#10;        assertNotNull(regularUser.getId(), &quot;Regular User ID should not be null after saving&quot;);&#10;        // Create and save an order for each test&#10;        order = new Order.OrderBuilder()&#10;                .setRegularUser(regularUser)&#10;                .setOrderDate(LocalDateTime.now())&#10;                .build();&#10;        &#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(1)&#10;    void save() {&#10;        // Create a new order with the initialized regular user&#10;        order = new Order.OrderBuilder()&#10;                .setRegularUser(regularUser)&#10;                .setOrderDate(LocalDateTime.now())&#10;                .build();&#10;&#10;        // Save the order using the service&#10;        Order savedOrder = orderService.save(order);&#10;&#10;        // Validate that the saved order is not null and has an ID&#10;        assertNotNull(savedOrder, &quot;Saved order should not be null&quot;);&#10;        assertNotNull(savedOrder.getOrderId(), &quot;Saved order ID should not be null&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(2)&#10;    void findById() {&#10;        // Ensure the order is saved before finding it&#10;        assertNotNull(order, &quot;Order should not be null before finding by ID&quot;);&#10;&#10;        // Find the order by ID&#10;        Order foundOrder = orderService.findById(order.getOrderId());&#10;&#10;        // Validate that the found order matches the original order&#10;        assertNotNull(foundOrder, &quot;Found order should not be null&quot;);&#10;        assertEquals(order.getOrderId(), foundOrder.getOrderId(), &quot;Found order ID should match the original order ID&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(3)&#10;    void update() {&#10;        // Ensure the order is saved before updating it&#10;        assertNotNull(order, &quot;Order should not be null before updating&quot;);&#10;&#10;        // Update the order's order date&#10;     Order updatedOrder = new Order.OrderBuilder()&#10;                .copy(order)&#10;                .setOrderDate(LocalDateTime.now().plusDays(1)) // Update to a new date&#10;                .build();&#10;&#10;        // Update the order using the service&#10;        Order savedUpdatedOrder = orderService.update(updatedOrder);&#10;&#10;        // Validate that the updated order is not null and has the new order date&#10;        assertNotNull(savedUpdatedOrder, &quot;Updated order should not be null&quot;);&#10;        assertEquals(updatedOrder.getOrderDate(), savedUpdatedOrder.getOrderDate(),&#10;                     &quot;Updated order date should match the new date&quot;);&#10;        assertEquals(order.getOrderId(), savedUpdatedOrder.getOrderId(),&#10;                     &quot;Updated order ID should match the original order ID&quot;);&#10;        assertEquals(order.getRegularUser().getId(), savedUpdatedOrder.getRegularUser().getId(),&#10;                     &quot;Updated order's regular user ID should match the original regular user ID&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(4)&#10;    void getAll() {&#10;        // Retrieve all orders&#10;        var orders = orderService.getAll();&#10;&#10;        // Validate that the list of orders is not null and contains at least one order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(5)&#10;    void findByRegularUserId() {&#10;        // Ensure the regular user is saved before finding orders by user ID&#10;        assertNotNull(regularUser.getId(), &quot;Regular User ID should not be null before finding orders&quot;);&#10;&#10;        // Find orders by regular user ID&#10;        var orders = orderService.findByRegularUserId(regularUser.getId());&#10;&#10;        // Validate that the list of orders is not null and contains the saved order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order for the regular user&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(6)&#10;    void findByOrderDate() {&#10;        // Ensure the order is saved before finding by order date&#10;        assertNotNull(order, &quot;Order should not be null before finding by order date&quot;);&#10;&#10;        // Find orders by order date&#10;        var orders = orderService.findByOrderDate(order.getOrderDate());&#10;&#10;        // Validate that the list of orders is not null and contains the saved order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order for the specified order date&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(7)&#10;    void deleteById() {&#10;        // Ensure the order is saved before deleting it&#10;        assertNotNull(order, &quot;Order should not be null before deletion&quot;);&#10;&#10;        // Delete the order by ID&#10;        boolean isDeleted = orderService.deleteById(order.getOrderId());&#10;&#10;        // Validate that the order was deleted successfully&#10;        assertTrue(isDeleted, &quot;Order should be deleted successfully&quot;);&#10;&#10;        // Attempt to find the deleted order by ID&#10;        assertThrows(RuntimeException.class, () -&gt; orderService.findById(order.getOrderId()),&#10;                     &quot;Finding a deleted order should throw an exception&quot;);&#10;    }&#10;}" />
=======
              <option name="originalContent" value="package com.booklify.service;&#10;&#10;import com.booklify.domain.Order;&#10;import com.booklify.domain.RegularUser;&#10;import com.booklify.repository.RegularUserRepository;&#10;import org.junit.jupiter.api.*;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.context.SpringBootTest;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.UUID;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;@SpringBootTest&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;@TestInstance(TestInstance.Lifecycle.PER_CLASS)&#10;class OrderServiceTest {&#10;&#10;    @Autowired&#10;    private OrderService orderService;&#10;&#10;    @Autowired&#10;    private RegularUserRepository regularUserRepository;&#10;&#10;    private Order order;&#10;    private RegularUser regularUser;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;&#10;        // Initialize a sample order with a regular user&#10;&#10;        String randomEmail = &quot;testUser2_&quot; + UUID.randomUUID() + &quot;@gmail.com&quot;; // Use a random email to avoid unique constraint violation&#10;        regularUser = new RegularUser.RegularUserBuilder()&#10;                .setFullName(&quot;Test User 2&quot;)&#10;                .setEmail(randomEmail)&#10;                .setPassword(&quot;password2&quot;)&#10;                .setDateJoined(LocalDateTime.now())&#10;                .build();&#10;        regularUser = regularUserRepository.save(regularUser);&#10;        assertNotNull(regularUser.getId(), &quot;Regular User ID should not be null after saving&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(1)&#10;    void save() {&#10;        // Create a new order with the initialized regular user&#10;        order = new Order.OrderBuilder()&#10;                .setRegularUser(regularUser)&#10;                .setOrderDate(LocalDateTime.now())&#10;                .build();&#10;&#10;        // Save the order using the service&#10;        Order savedOrder = orderService.save(order);&#10;&#10;        // Validate that the saved order is not null and has an ID&#10;        assertNotNull(savedOrder, &quot;Saved order should not be null&quot;);&#10;        assertNotNull(savedOrder.getOrderId(), &quot;Saved order ID should not be null&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(2)&#10;    void findById() {&#10;        // Ensure the order is saved before finding it&#10;        assertNotNull(order, &quot;Order should not be null before finding by ID&quot;);&#10;&#10;        // Find the order by ID&#10;        Order foundOrder = orderService.findById(order.getOrderId());&#10;&#10;        // Validate that the found order matches the original order&#10;        assertNotNull(foundOrder, &quot;Found order should not be null&quot;);&#10;        assertEquals(order.getOrderId(), foundOrder.getOrderId(), &quot;Found order ID should match the original order ID&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(3)&#10;    void update() {&#10;        // Ensure the order is saved before updating it&#10;        assertNotNull(order, &quot;Order should not be null before updating&quot;);&#10;&#10;        // Update the order's order date&#10;     Order updatedOrder = new Order.OrderBuilder()&#10;                .copy(order)&#10;                .setOrderDate(LocalDateTime.now().plusDays(1)) // Update to a new date&#10;                .build();&#10;&#10;        // Update the order using the service&#10;        Order savedUpdatedOrder = orderService.update(updatedOrder);&#10;&#10;        // Validate that the updated order is not null and has the new order date&#10;        assertNotNull(savedUpdatedOrder, &quot;Updated order should not be null&quot;);&#10;        assertEquals(updatedOrder.getOrderDate(), savedUpdatedOrder.getOrderDate(),&#10;                     &quot;Updated order date should match the new date&quot;);&#10;        assertEquals(order.getOrderId(), savedUpdatedOrder.getOrderId(),&#10;                     &quot;Updated order ID should match the original order ID&quot;);&#10;        assertEquals(order.getRegularUser().getId(), savedUpdatedOrder.getRegularUser().getId(),&#10;                     &quot;Updated order's regular user ID should match the original regular user ID&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(4)&#10;    void getAll() {&#10;        // Retrieve all orders&#10;        var orders = orderService.getAll();&#10;&#10;        // Validate that the list of orders is not null and contains at least one order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(5)&#10;    void findByRegularUserId() {&#10;        // Ensure the regular user is saved before finding orders by user ID&#10;        assertNotNull(regularUser.getId(), &quot;Regular User ID should not be null before finding orders&quot;);&#10;&#10;        // Find orders by regular user ID&#10;        var orders = orderService.findByRegularUserId(regularUser.getId());&#10;&#10;        // Validate that the list of orders is not null and contains the saved order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order for the regular user&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(6)&#10;    void findByOrderDate() {&#10;        // Ensure the order is saved before finding by order date&#10;        assertNotNull(order, &quot;Order should not be null before finding by order date&quot;);&#10;&#10;        // Find orders by order date&#10;        var orders = orderService.findByOrderDate(order.getOrderDate());&#10;&#10;        // Validate that the list of orders is not null and contains the saved order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order for the specified order date&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(7)&#10;    void deleteById() {&#10;        // Ensure the order is saved before deleting it&#10;        assertNotNull(order, &quot;Order should not be null before deletion&quot;);&#10;&#10;        // Delete the order by ID&#10;        boolean isDeleted = orderService.deleteById(order.getOrderId());&#10;&#10;        // Validate that the order was deleted successfully&#10;        assertTrue(isDeleted, &quot;Order should be deleted successfully&quot;);&#10;&#10;        // Attempt to find the deleted order by ID&#10;        assertThrows(RuntimeException.class, () -&gt; orderService.findById(order.getOrderId()),&#10;                     &quot;Finding a deleted order should throw an exception&quot;);&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.booklify.service;&#10;&#10;import com.booklify.domain.Order;&#10;import com.booklify.domain.RegularUser;&#10;import com.booklify.repository.RegularUserRepository;&#10;import org.junit.jupiter.api.*;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.context.SpringBootTest;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.UUID;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;&#10;@SpringBootTest&#10;@TestMethodOrder(MethodOrderer.OrderAnnotation.class)&#10;@TestInstance(TestInstance.Lifecycle.PER_CLASS)&#10;class OrderServiceTest {&#10;&#10;    @Autowired&#10;    private OrderService orderService;&#10;&#10;    @Autowired&#10;    private RegularUserRepository regularUserRepository;&#10;&#10;    private Order order;&#10;    private RegularUser regularUser;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Use a random email to avoid unique constraint violation&#10;        String randomEmail = &quot;testUser2_&quot; + UUID.randomUUID() + &quot;@gmail.com&quot;;&#10;        regularUser = new RegularUser.RegularUserBuilder()&#10;                .setFullName(&quot;Test User 2&quot;)&#10;                .setEmail(randomEmail)&#10;                .setPassword(&quot;password2&quot;)&#10;                .setDateJoined(LocalDateTime.now())&#10;                .build();&#10;        regularUser = regularUserRepository.save(regularUser);&#10;        assertNotNull(regularUser.getId(), &quot;Regular User ID should not be null after saving&quot;);&#10;        // Create and save an order for each test&#10;        order = new Order.OrderBuilder()&#10;                .setRegularUser(regularUser)&#10;                .setOrderDate(LocalDateTime.now())&#10;                .build();&#10;        order = orderService.save(order);&#10;        assertNotNull(order.getOrderId(), &quot;Order ID should not be null after saving&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(1)&#10;    void save() {&#10;        // Create a new order with the initialized regular user&#10;        order = new Order.OrderBuilder()&#10;                .setRegularUser(regularUser)&#10;                .setOrderDate(LocalDateTime.now())&#10;                .build();&#10;&#10;        // Save the order using the service&#10;        Order savedOrder = orderService.save(order);&#10;&#10;        // Validate that the saved order is not null and has an ID&#10;        assertNotNull(savedOrder, &quot;Saved order should not be null&quot;);&#10;        assertNotNull(savedOrder.getOrderId(), &quot;Saved order ID should not be null&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(2)&#10;    void findById() {&#10;        // Ensure the order is saved before finding it&#10;        assertNotNull(order, &quot;Order should not be null before finding by ID&quot;);&#10;&#10;        // Find the order by ID&#10;        Order foundOrder = orderService.findById(order.getOrderId());&#10;&#10;        // Validate that the found order matches the original order&#10;        assertNotNull(foundOrder, &quot;Found order should not be null&quot;);&#10;        assertEquals(order.getOrderId(), foundOrder.getOrderId(), &quot;Found order ID should match the original order ID&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(3)&#10;    void update() {&#10;        // Ensure the order is saved before updating it&#10;        assertNotNull(order, &quot;Order should not be null before updating&quot;);&#10;&#10;        // Update the order's order date&#10;     Order updatedOrder = new Order.OrderBuilder()&#10;                .copy(order)&#10;                .setOrderDate(LocalDateTime.now().plusDays(1)) // Update to a new date&#10;                .build();&#10;&#10;        // Update the order using the service&#10;        Order savedUpdatedOrder = orderService.update(updatedOrder);&#10;&#10;        // Validate that the updated order is not null and has the new order date&#10;        assertNotNull(savedUpdatedOrder, &quot;Updated order should not be null&quot;);&#10;        assertEquals(updatedOrder.getOrderDate(), savedUpdatedOrder.getOrderDate(),&#10;                     &quot;Updated order date should match the new date&quot;);&#10;        assertEquals(order.getOrderId(), savedUpdatedOrder.getOrderId(),&#10;                     &quot;Updated order ID should match the original order ID&quot;);&#10;        assertEquals(order.getRegularUser().getId(), savedUpdatedOrder.getRegularUser().getId(),&#10;                     &quot;Updated order's regular user ID should match the original regular user ID&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(4)&#10;    void getAll() {&#10;        // Retrieve all orders&#10;        var orders = orderService.getAll();&#10;&#10;        // Validate that the list of orders is not null and contains at least one order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(5)&#10;    void findByRegularUserId() {&#10;        // Ensure the regular user is saved before finding orders by user ID&#10;        assertNotNull(regularUser.getId(), &quot;Regular User ID should not be null before finding orders&quot;);&#10;&#10;        // Find orders by regular user ID&#10;        var orders = orderService.findByRegularUserId(regularUser.getId());&#10;&#10;        // Validate that the list of orders is not null and contains the saved order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order for the regular user&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(6)&#10;    void findByOrderDate() {&#10;        // Ensure the order is saved before finding by order date&#10;        assertNotNull(order, &quot;Order should not be null before finding by order date&quot;);&#10;&#10;        // Find orders by order date&#10;        var orders = orderService.findByOrderDate(order.getOrderDate());&#10;&#10;        // Validate that the list of orders is not null and contains the saved order&#10;        assertNotNull(orders, &quot;Orders list should not be null&quot;);&#10;        assertFalse(orders.isEmpty(), &quot;Orders list should not be empty&quot;);&#10;        assertTrue(orders.stream().anyMatch(o -&gt; o.getOrderId().equals(order.getOrderId())),&#10;                   &quot;Orders list should contain the saved order for the specified order date&quot;);&#10;    }&#10;&#10;    @Test&#10;    @org.junit.jupiter.api.Order(7)&#10;    void deleteById() {&#10;        // Ensure the order is saved before deleting it&#10;        assertNotNull(order, &quot;Order should not be null before deletion&quot;);&#10;&#10;        // Delete the order by ID&#10;        boolean isDeleted = orderService.deleteById(order.getOrderId());&#10;&#10;        // Validate that the order was deleted successfully&#10;        assertTrue(isDeleted, &quot;Order should be deleted successfully&quot;);&#10;&#10;        // Attempt to find the deleted order by ID&#10;        assertThrows(RuntimeException.class, () -&gt; orderService.findById(order.getOrderId()),&#10;                     &quot;Finding a deleted order should throw an exception&quot;);&#10;    }&#10;}" />
>>>>>>> 993b2a6 (Update)
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>